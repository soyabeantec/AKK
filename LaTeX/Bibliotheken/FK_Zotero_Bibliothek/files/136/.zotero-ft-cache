pricing user guide plotly
Basic Dash Callbacks

    This is the 3rd chapter of the Dash Tutorial . The previous chapter covered the Dash app layout and the next chapter covers an additional concept of callbacks known as state . Just getting started? Make sure to install the necessary dependencies .

In the previous chapter on the app.layout we learned that the app.layout describes what the app looks like and is a hierarchical tree of components. The dash_html_components library provides classes for all of the HTML tags, and the keyword arguments describe the HTML attributes like style , className , and id . The dash_core_components library generates higher-level components like controls and graphs.

This chapter describes how to make your Dash apps interactive.

Let's get started with a simple example.
Dash App Layout

 import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] app = dash.Dash(__name__, external_stylesheets=external_stylesheets) app.layout = html.Div([ dcc.Input(id= 'my-id' , value= 'initial value' , type= 'text' ), html.Div(id= 'my-div' ) ]) @app.callback( Output(component_id= 'my-div' , component_property= 'children' ), [Input(component_id= 'my-id' , component_property= 'value' )] ) def update_output_div (input_value) : return 'You\'ve entered "{}"' .format(input_value) if __name__ == '__main__' : app.run_server(debug= True ) 

You've entered "initial value"

Try typing in the text box. The children of the output component updates right away. Let's break down what's happening here:

    The "inputs" and "outputs" of our application interface are described declaratively through the app.callback decorator.
    In Dash, the inputs and outputs of our application are simply the properties of a particular component. In this example, our input is the " value " property of the component that has the ID " my-id ". Our output is the " children " property of the component with the ID " my-div ".
    Whenever an input property changes, the function that the callback decorator wraps will get called automatically. Dash provides the function with the new value of the input property as an input argument and Dash updates the property of the output component with whatever was returned by the function.
    The component_id and component_property keywords are optional (there are only two arguments for each of those objects). I have included them here for clarity but I will omit them from here on out for brevity and readability.
    Don't confuse the dash.dependencies.Input object from the dash_core_components.Input object. The former is just used in these callbacks and the latter is an actual component.
    Notice how we don't set a value for the children property of the my-div component in the layout . When the Dash app starts, it automatically calls all of the callbacks with the initial values of the input components in order to populate the initial state of the output components. In this example, if you specified something like html.Div(id='my-div', children='Hello world') , it would get overwritten when the app starts.

It's sort of like programming with Microsoft Excel: whenever an input cell changes, all of the cells that depend on that cell will get updated automatically. This is called "Reactive Programming".

Remember how every component was described entirely through its set of keyword arguments? Those properties are important now. With Dash interactivity, we can dynamically update any of those properties through a callback function. Frequently we'll update the children of a component to display new text or the figure of a dcc.Graph component to display new data, but we could also update the style of a component or even the available options of a dcc.Dropdown component!

Let's take a look at another example where a dcc.Slider updates a dcc.Graph .

 import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output import pandas as pd import plotly.graph_objs as go df = pd.read_csv( 'https://raw.githubusercontent.com/plotly/' 'datasets/master/gapminderDataFiveYear.csv' ) external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] app = dash.Dash(__name__, external_stylesheets=external_stylesheets) app.layout = html.Div([ dcc.Graph(id= 'graph-with-slider' ), dcc.Slider( id= 'year-slider' , min=df[ 'year' ].min(), max=df[ 'year' ].max(), value=df[ 'year' ].min(), marks={str(year): str(year) for year in df[ 'year' ].unique()}, step= None ) ]) @app.callback( Output( 'graph-with-slider' , 'figure' ), [Input( 'year-slider' , 'value' )]) def update_figure (selected_year) : filtered_df = df[df.year == selected_year] traces = [] for i in filtered_df.continent.unique(): df_by_continent = filtered_df[filtered_df[ 'continent' ] == i] traces.append(go.Scatter( x=df_by_continent[ 'gdpPercap' ], y=df_by_continent[ 'lifeExp' ], text=df_by_continent[ 'country' ], mode= 'markers' , opacity= 0.7 , marker={ 'size' : 15 , 'line' : { 'width' : 0.5 , 'color' : 'white' } }, name=i )) return { 'data' : traces, 'layout' : go.Layout( xaxis={ 'type' : 'log' , 'title' : 'GDP Per Capita' }, yaxis={ 'title' : 'Life Expectancy' , 'range' : [ 20 , 90 ]}, margin={ 'l' : 40 , 'b' : 40 , 't' : 10 , 'r' : 10 }, legend={ 'x' : 0 , 'y' : 1 }, hovermode= 'closest' ) } if __name__ == '__main__' : app.run_server(debug= True ) 

2 3 4 5 6 7 8 9 1000 2 3 4 5 6 7 8 9 10k 2 3 4 5 6 7 8 9 100k 20 30 40 50 60 70 80 90
Asia Europe Africa Americas Oceania GDP Per Capita Life Expectancy
.cls-1 {fill: #119dff;} .cls-2 {fill: #25fefd;} .cls-3 {fill: #fff;} plotly-logomark
1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007

In this example, the "value" property of the Slider is the input of the app and the output of the app is the "figure" property of the Graph . Whenever the value of the Slider changes, Dash calls the callback function update_figure with the new value. The function filters the dataframe with this new value, constructs a figure object, and returns it to the Dash application.

There are a few nice patterns in this example:

    We're using the Pandas library for importing and filtering datasets in memory.
    We load our dataframe at the start of the app: df = pd.read_csv('...') . This dataframe df is in the global state of the app and can be read inside the callback functions.
    Loading data into memory can be expensive. By loading querying data at the start of the app instead of inside the callback functions, we ensure that this operation is only done when the app server starts. When a user visits the app or interacts with the app, that data (the df ) is already in memory. If possible, expensive initialization (like downloading or querying data) should be done in the global scope of the app instead of within the callback functions.
    The callback does not modify the original data, it just creates copies of the dataframe by filtered through pandas filters. This is important: your callbacks should never mutate variables outside of their scope . If your callbacks modify global state, then one user's session might affect the next user's session and when the app is deployed on multiple processes or threads, those modifications will not be shared across sessions.

Multiple inputs

In Dash, any " Output " can have multiple " Input " components. Here's a simple example that binds five Inputs (the value property of 2 Dropdown components, 2 RadioItems components, and 1 Slider component) to 1 Output component (the figure property of the Graph component). Notice how the app.callback lists all five dash.dependencies.Input inside a list in the second argument.

 import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output import pandas as pd import plotly.graph_objs as go external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] app = dash.Dash(__name__, external_stylesheets=external_stylesheets) df = pd.read_csv( 'https://gist.githubusercontent.com/chriddyp/' 'cb5392c35661370d95f300086accea51/raw/' '8e0768211f6b747c0db42a9ce9a0937dafcbd8b2/' 'indicators.csv' ) available_indicators = df[ 'Indicator Name' ].unique() app.layout = html.Div([ html.Div([ html.Div([ dcc.Dropdown( id= 'xaxis-column' , options=[{ 'label' : i, 'value' : i} for i in available_indicators], value= 'Fertility rate, total (births per woman)' ), dcc.RadioItems( id= 'xaxis-type' , options=[{ 'label' : i, 'value' : i} for i in [ 'Linear' , 'Log' ]], value= 'Linear' , labelStyle={ 'display' : 'inline-block' } ) ], style={ 'width' : '48%' , 'display' : 'inline-block' }), html.Div([ dcc.Dropdown( id= 'yaxis-column' , options=[{ 'label' : i, 'value' : i} for i in available_indicators], value= 'Life expectancy at birth, total (years)' ), dcc.RadioItems( id= 'yaxis-type' , options=[{ 'label' : i, 'value' : i} for i in [ 'Linear' , 'Log' ]], value= 'Linear' , labelStyle={ 'display' : 'inline-block' } ) ],style={ 'width' : '48%' , 'float' : 'right' , 'display' : 'inline-block' }) ]), dcc.Graph(id= 'indicator-graphic' ), dcc.Slider( id= 'year--slider' , min=df[ 'Year' ].min(), max=df[ 'Year' ].max(), value=df[ 'Year' ].max(), marks={str(year): str(year) for year in df[ 'Year' ].unique()}, step= None ) ]) @app.callback( Output( 'indicator-graphic' , 'figure' ), [Input( 'xaxis-column' , 'value' ), Input( 'yaxis-column' , 'value' ), Input( 'xaxis-type' , 'value' ), Input( 'yaxis-type' , 'value' ), Input( 'year--slider' , 'value' )]) def update_graph (xaxis_column_name, yaxis_column_name, xaxis_type, yaxis_type, year_value) : dff = df[df[ 'Year' ] == year_value] return { 'data' : [go.Scatter( x=dff[dff[ 'Indicator Name' ] == xaxis_column_name][ 'Value' ], y=dff[dff[ 'Indicator Name' ] == yaxis_column_name][ 'Value' ], text=dff[dff[ 'Indicator Name' ] == yaxis_column_name][ 'Country Name' ], mode= 'markers' , marker={ 'size' : 15 , 'opacity' : 0.5 , 'line' : { 'width' : 0.5 , 'color' : 'white' } } )], 'layout' : go.Layout( xaxis={ 'title' : xaxis_column_name, 'type' : 'linear' if xaxis_type == 'Linear' else 'log' }, yaxis={ 'title' : yaxis_column_name, 'type' : 'linear' if yaxis_type == 'Linear' else 'log' }, margin={ 'l' : 40 , 'b' : 40 , 't' : 10 , 'r' : 0 }, hovermode= 'closest' ) } if __name__ == '__main__' : app.run_server(debug= True ) 

Fertility rate, total (births per woman)
×
Linear Log
Life expectancy at birth, total (years)
×
Linear Log
1 2 3 4 5 6 7 8 45 50 55 60 65 70 75 80 85
Fertility rate, total (births per woman) Life expectancy at birth, total (years)
.cls-1 {fill: #119dff;} .cls-2 {fill: #25fefd;} .cls-3 {fill: #fff;} plotly-logomark
1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007

In this example, the update_graph function gets called whenever the value property of the Dropdown , Slider , or RadioItems components change.

The input arguments of the update_graph function are the new or current value of each of the Input properties, in the order that they were specified.

Even though only a single Input changes at a time (a user can only change the value of a single Dropdown in a given moment), Dash collects the current state of all of the specified Input properties and passes them into your function for you. Your callback functions are always guaranteed to be passed the representative state of the app.

Let's extend our example to include multiple outputs.
Multiple Outputs

New in dash 0.39.0

So far all the callbacks we've written only update a single Output property. We can also update several at once: put all the properties you want to update as a list in the decorator, and return that many items from the callback. This is particularly nice if two outputs depend on the same computationally intense intermediate result, such as a slow database query.

 import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] app = dash.Dash(__name__, external_stylesheets=external_stylesheets) app.layout = html.Div([ dcc.Input( id= 'num' , type= 'number' , value= 5 ), html.Table([ html.Tr([html.Td([ 'x' , html.Sup( 2 )]), html.Td(id= 'square' )]), html.Tr([html.Td([ 'x' , html.Sup( 3 )]), html.Td(id= 'cube' )]), html.Tr([html.Td([ 2 , html.Sup( 'x' )]), html.Td(id= 'twos' )]), html.Tr([html.Td([ 3 , html.Sup( 'x' )]), html.Td(id= 'threes' )]), html.Tr([html.Td([ 'x' , html.Sup( 'x' )]), html.Td(id= 'x^x' )]), ]), ]) @app.callback( [Output( 'square' , 'children' ), Output( 'cube' , 'children' ), Output( 'twos' , 'children' ), Output( 'threes' , 'children' ), Output( 'x^x' , 'children' )], [Input( 'num' , 'value' )]) def callback_a (x) : return x** 2 , x** 3 , 2 **x, 3 **x, x**x if __name__ == '__main__' : app.run_server(debug= True ) 

x 2 	25
x 3 	125
2 x 	32
3 x 	243
x x 	3125

A word of caution: it's not always a good idea to combine Outputs, even if you can:

    If the Outputs depend on some but not all of the same Inputs, keeping them separate can avoid unnecessary updates.
    If they have the same Inputs but do independent computations with these inputs, keeping the callbacks separate can allow them to run in parallel.

Chained Callbacks

You can also chain outputs and inputs together: the output of one callback function could be the input of another callback function.

This pattern can be used to create dynamic UIs where one input component updates the available options of the next input component. Here's a simple example.

 # -*- coding: utf-8 -*- import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] app = dash.Dash(__name__, external_stylesheets=external_stylesheets) all_options = { 'America' : [ 'New York City' , 'San Francisco' , 'Cincinnati' ], 'Canada' : [ u'Montréal' , 'Toronto' , 'Ottawa' ] } app.layout = html.Div([ dcc.RadioItems( id= 'countries-dropdown' , options=[{ 'label' : k, 'value' : k} for k in all_options.keys()], value= 'America' ), html.Hr(), dcc.RadioItems(id= 'cities-dropdown' ), html.Hr(), html.Div(id= 'display-selected-values' ) ]) @app.callback( Output( 'cities-dropdown' , 'options' ), [Input( 'countries-dropdown' , 'value' )]) def set_cities_options (selected_country) : return [{ 'label' : i, 'value' : i} for i in all_options[selected_country]] @app.callback( Output( 'cities-dropdown' , 'value' ), [Input( 'cities-dropdown' , 'options' )]) def set_cities_value (available_options) : return available_options[ 0 ][ 'value' ] @app.callback( Output( 'display-selected-values' , 'children' ), [Input( 'countries-dropdown' , 'value' ), Input( 'cities-dropdown' , 'value' )]) def set_display_children (selected_country, selected_city) : return u'{} is a city in {}' .format( selected_city, selected_country, ) if __name__ == '__main__' : app.run_server(debug= True ) 

America Canada
New York City San Francisco Cincinnati
New York City is a city in America

The first callback updates the available options in the second RadioItems component based off of the selected value in the first RadioItems component.

The second callback sets an initial value when the options property changes: it sets it to the first value in that options array.

The final callback displays the selected value of each component. If you change the value of the countries RadioItems component, Dash will wait until the value of the cities component is updated before calling the final callback. This prevents your callbacks from being called with inconsistent state like with "America" and "Montréal" .
Summary

We've covered the fundamentals of callbacks in Dash. Dash apps are built off of a set of simple but powerful principles: declarative UIs that are customizable through reactive and functional Python callbacks. Every element attribute of the declarative components can be updated through a callback and a subset of the attributes, like the value properties of the dcc.Dropdown , are editable by the user in the interface.

The next part of the Dash tutorial covers an additional concept of Dash callbacks: State
Dash Tutorial Part 4: State
Back to the Table of Contents
